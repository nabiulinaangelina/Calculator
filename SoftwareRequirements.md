# Требования к программному обеспечению

Требования к проекту «Расширенный калькулятор» (индивидуальное задание для итогового проекта по курсу «ОиМП»).

**Тема:** Разработка консольного объектно-ориентированного приложения с расширенными возможностями. Консольный калькулятор «Расширенный калькулятор», который по функционалу напоминает калькулятор от Microsoft, поддерживает разные режимы (стандартный; инженерный; программиста; вычисление выражений; работа с числами; работа со строками; работа с датами; сортировки массивов данных, загруженных из файла и сохраненных в файл), сохранение истории операций и работу с файлами.
**Цель проекта:** Демонстрация глубокого понимания принципов объектно-ориентированного программирования (ООП), умения применять стандартные библиотеки C++ (STL), реализовывать собственные структуры данных, организовывать взаимодействие с файловой системой, использовать аргументы командной строки, а также обеспечивать качество кода через тестирование и журналирование.
**Формат сдачи:** Готовый проект, размещенный в публичном репозитории GitHub, в котором выполнялись регулярные коммиты на протяжении октябрь-декабрь 2025 года.
**Баллы за проект:** Максимум 100 баллов (оценивается вашим преподавателем по практике + может быть скорректирована лектором).
**Автор:** это индивидуальный проект, командная разработка не предполагается.

# Требования к проекту
## 1. Проектирование и реализация основной логики 
### ООП: 
- Класс Calculator, реализующий шаблон Singleton, и хранящий историю выполненных команд, чтобы можно было «отменить» или повторить операцию; хранилище введенных данных, чтобы команда из него сама забирала аргументы, столько, сколько ей нужно.
- Базовый класс Command, от которого наследуются два специализированных класса: UnaryCommand и BinaryCommand, от которых в свою очередь наследуются реальные классы команд (операций), например, AddCommand, SqrtCommand – реализация шаблона Command.
- и другие, которые нужны для реалирации работы приложения
### Функциональность: 
- StandardCalculator: +, -, -, /, sqrt (собственная реализация, а не вызов функций стандартной библиотеки) и др. 
- ProgrammerCalculator (собственная реализация, а не вызов функций стандартной библиотеки): AND, OR, XOR, NOT, сдвиги (<<, >>), преобразование между системами счисления (DEC, BIN, HEX) и др.
- ScientificCalculator  (собственная реализация, а не вызов функций стандартной библиотеки): sin, cos, tan, log, exp, pow и др.
- Еxpression evaluation: вычисление выражений на основе с использованием обратной польской записи.
- Работа с числами: разные задачи по работе с цифрами числа (из лабораторных работ).
- Работа со строками: разные задачи по работе с символами, строками (из лабораторных работ).
- Работа с датами: разные задачи по работе с датами (из лабораторных работ).
- Сортировки массивов: собственная реализация различных алгоритмов сортировки, данных загружаются из файла и сохраненных в файл (из лабораторных работ).

## 2. Пользовательский Интерфейс и Взаимодействие
- Двухуровневое меню: 
    - 1-й уровень: “Выбор режима”: 
1. стандартный, 
2. инженерный, 
3. программист, 
4. вычисление выражений,
5. работа с числами,
6. работа со строками,
7. работа с датами,
8. сортировки массивов данных,
9. история, 
10. выход. 
    - 2-й уровень: (зависит от выбранного режима) 
- Для стандартного режима: "+", "-", "-", "/", "sqrt",  и др., "Назад". 
- Для режима история: "Показать", "Очистить", "Сохранить в файл", "Загрузить из файла", "Назад". 
- и т.д.
- Аргументы командной строки: 
- app_calculator.exe --mode=programmer (запустить сразу в режиме программиста). 
- app_calculator.exe  --calculate="5 + 33" (выполнить операцию и вывести результат). 
- app_calculator.exe  --load-history history.txt (загрузить историю при запуске). 
- app_calculator.exe  --log-level=DEBUG (установить уровень логирования). 

## 3. Работа с Файлами и Данными
- Чтение/запись: сохраняет и загружает историю операций из файла (например, history.txt / history.json / в бинарном файле - сериализованное представление команд, расширение файла, например history.commands.
- Загрузка выражения для вычисления: Например, в файле expression.txt в текстовом формате записана строка выражения, которое нужно вычислить.
- Чтение/запись: данных для сортировки элементов массива.

## 4. Использование Библиотек и Структур Данных
### 4.1. Стандартная библиотека шаблонов (STL)
- Контейнеры (примеры использования): 
    - std::stack<double> dataStack – для хранения данных, над которыми выполняются операции; 
std::vector<…> – для хранения истории вводимых пользователем выражений.  Это обеспечивает динамическое изменение размера истории, удобный доступ к элементам и совместимость с алгоритмами STL.
    - std::map<std::string, …> – для хранения ассоциаций между строковым представлением операции (например, "+", "sin") и соответствующей командой, выполняющей эту операцию. Это обеспечивает гибкое добавление новых операций без изменения структуры кода.
    - std::set<std::string> (опционально): Для хранения множества доступных операций в каждом режиме калькулятора, что упрощает проверку корректности ввода пользователя.
- и др.
- Алгоритмы (примеры использования): 
    - std::for_each – для вывода истории операций.
    - std::transform – для преобразования элементов истории (например, для форматирования вывода).
    - std::find_if – для поиска определенной операции в истории по критерию (например, операции, содержащие определенное число).
    -   std::sort – например, для реализации возможности сортировки истории по дате, значению и т.п.
    - и др.
- Функциональные объекты/Лямбда-выражения (примеры использования): 
    - Лямбда-выражения для передачи в алгоритмы STL (std::for_each, std::find_if) для определения критериев поиска или преобразования.
    - Функциональные объекты (например, std::plus, std::minus) для выполнения стандартных арифметических операций).
- Итераторы: 
    - Использовать итераторы для перебора элементов контейнеров (std::vector, std::map) при выводе истории, поиске, применении алгоритмов.

### 4.2. Структура данных:
*Реализовать собственную версию линейных структур данных (шаблон) (в зависимости от того, как разработчиком приложения будут реализованы операции калькулятора):
- Стек (Stack) – в проекте планируется реализация стекового калькулятора или парсинг математических выражений – вычисление выражений с реализацией обратной польской записи. Например, MyStack<double> для хранения операндов при вычислении выражений в стековом калькуляторе.
- Односвязный список (Singly Linked List) – альтернатива std::vector для хранения истории операций, демонстрирующая работу с указателями и динамической памятью). Например, MyLinkedList<…> для хранения истории операций.
-  Двусвязный список (Doubly Linked List) – расширенная версия односвязного списка, обеспечивающая более эффективный доступ к элементам в обоих направлениях. Можно использовать для истории операций, если требуется быстрое перемещение по истории вперед и назад).
- Очередь (Queue) – может быть использована, например, для управления очередью задач на вычисление.
- Бинарное дерево – вычисления арифметического выражения через бинарное дерево , у которого листья – числовые значения, внутренние узлы – операции, этап 1 – парсинг строки-выражения в дерево, этап 2 – симметричный обход по дереву, для вычисления выражения.

#### Требования к реализации структуры данных: 
-   Структура должна быть шаблонной: template <typename T> class MyStack { ... }.
-   Структура должна предоставлять следующие методы:
- Добавление элемента: push(T value) (для стека/очереди), insert(T value) (для списка / дерева).
- Удаление элемента: pop() (для стека/очереди), remove(T value) или removeAt(int index) (для списка/дерева).
- Проверка на пустоту: isEmpty().
- Получение размера: size().
- (Для списка) Поиск элемента по значению или индексу: find(T value), get(int index).

#### Критерии оценки реализации структур данных: 
- Корректность реализации: Структура данных должна корректно выполнять все заявленные операции без ошибок и утечек памяти.
- Эффективность: Реализация должна быть достаточно эффективной для задач, решаемых в проекте.
- Применение в проекте: Структура данных должна быть использована в проекте для решения конкретной задачи, а не просто для демонстрации факта реализации.
- Соответствие требованиям: Реализация должна соответствовать всем указанным требованиям (шаблонность, наличие необходимых методов).

## 5. Качество кода и документирование 
### 5.1. Модульное тестирование 
- Использование фреймворка для модульного тестирования (Google Test). 
- Создать набор модульных тестов, покрывающий ключевые функции и методы классов. 
- Тесты должны проверять как корректное выполнение, так и обработку ошибочных ситуаций. 
### 5.2. Журналирование событий 
- Реализовать систему журналирования (логирования) событий (с использованием библиотеки spdlog). 
- Должны быть предусмотрены разные уровни журналирования (например, DEBUG, INFO, WARNING, ERROR). 
- Сообщения должны выводиться на консоль / в файл (в зависимости от стартовой конфигурации, которая считывается, как аргументы командной строки). 
### 5.3. Документация и стиль кода 
- Код должен быть хорошо прокомментирован (Doxygen-стиль для публичных интерфейсов). 
- Соблюдение общепринятого стиля кодирования, определенного в данном курсе. 
- Наличие README.md файла в репозитории с инструкциями по сборке и запуску приложения, описанием функционала и использования аргументов командной строки. 
